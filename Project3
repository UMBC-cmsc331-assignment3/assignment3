

; Make a list of n length
(define (makelist n)
  (if (= n 1)
    (list 1)
    (cons n (makelist (- n 1)))))


; Randomize the list
(define (random-sort list)
  (sort list
    (lambda (x y)
      (equal? 0 (random 2)))))


; Break into k-sized tuples
(define (split-by lst k)
  (if (not (null? lst))
    (cons (sort (take lst k) < ) (split-by (drop lst k) k))
    '() ))


; Number of occurences in a list
(define (occurence x lst)
  (if (null? lst) 
    0
    (if (equal? x (car lst)) 
      (+ 1 (occurence x (cdr lst)))
      (occurence x (cdr lst)))))


; Make candidate grouping
(define (make-group n k)
  (split-by (random-sort (makelist n)) k))


; Make all groupings
(define (make-groupings n k num)
  (if (= num 1)
    (cons (split-by (random-sort (makelist n)) k) '() ) 
    (cons (split-by (random-sort (makelist n)) k) (make-groupings n k (- num 1) ))))
  


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;; Sorting borrowed from the following web page
;;; http://groups.engin.umd.umich.edu/CIS/course.des/cis400/scheme/sorts.html
;;; (merge! a b less?)
;;; takes two sorted lists a and b and smashes their cdr fields to form a
;;; single sorted list including the elements of both.
;;; Note:  this does _not_ accept vectors.

(define (merge! a b less?)
    (define (loop r a b)
         (if (less? (car b) (car a))
             (begin
                 (set-cdr! r b)
                 (if (null? (cdr b))
                     (set-cdr! b a)
                     (loop b a (cdr b)) ))
             ;; (car a) <= (car b)
             (begin
                 (set-cdr! r a)
                 (if (null? (cdr a))
                     (set-cdr! a b)
                     (loop a (cdr a) b)) )) )
    (cond
         ((null? a) b)
         ((null? b) a)
         ((less? (car b) (car a))
             (if (null? (cdr b))
                 (set-cdr! b a)
                 (loop b a (cdr b)))
             b)
         (else ; (car a) <= (car b)
             (if (null? (cdr a))
                 (set-cdr! a b)
                 (loop a (cdr a) b))
             a)))


;;; (sort! sequence less?)
;;; sorts the list or vector sequence destructively.  It uses a version
;;; of merge-sort invented, to the best of my knowledge, by David H. D.
;;; Warren, and first used in the DEC-10 Prolog system.  R. A. O'Keefe
;;; adapted it to work destructively in Scheme.

(define (sort! seq less?)
    (define (step n)
         (cond
             ((> n 2)
                 (let* ((j (quotient n 2))
                        (a (step j))
                        (k (- n j))
                        (b (step k)))
                     (merge! a b less?)))
             ((= n 2)
                 (let ((x (car seq))
                       (y (cadr seq))
                       (p seq))
                     (set! seq (cddr seq))
                     (if (less? y x) (begin
                         (set-car! p y)
                         (set-car! (cdr p) x)))
                     (set-cdr! (cdr p) '())
                     p))
             ((= n 1)
                 (let ((p seq))
                     (set! seq (cdr seq))
                     (set-cdr! p '())
                     p))
             (else
                 '()) ))
    (if (vector? seq)
         (let ((n (vector-length seq))
               (vector seq))                     ; save original vector
             (set! seq (vector->list seq))       ; convert to list
             (do ((p (step n) (cdr p))           ; sort list destructively
                  (i 0 (+ i 1)))                         ; and store elements back
                 ((null? p) vector)              ; in original vector
                 (vector-set! vector i (car p)) ))
         ;; otherwise, assume it is a list
         (step (length seq)) ))


;;; (sort sequence less?)
;;; sorts a vector or list non-destructively.  It does this by sorting a
;;; copy of the sequence
(define (sort seq less?)
    (if (vector? seq)
         (list->vector (sort! (vector->list seq) less?))
         (sort! (append seq '()) less?)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;







;(display (list-of-lists 10 2 2) )
;(display (split-by (list-of-lists 10 2 2) 4 ))
;(display (occurence (cons '1 '(3)) (split-by (cons '1 '(2 3 4)) 2) ))
;(display (make-group 10 2))
;(display (make-groupings 10 2 8))

(define n 20)
(define k 4)

(display "\n")
(display "\n")
(display   "Assignment 1: ")
(display (make-group n k))
(display "\nAssignment 2: ")
(display (make-group n k))
(display "\nAssignment 3: ")
(display (make-group n k))
(display "\nMidterm:      ")
(display (make-group n k))
(display "\nAssignment 4: ")
(display (make-group n k))
(display "\nAssignment 5: ")
(display (make-group n k))
(display "\nAssignment 6: ")
(display (make-group n k))
(display "\nFinal Exam:   ")
(display (make-group n k))
(display "\n")
(display "\n")
(display "\n")


