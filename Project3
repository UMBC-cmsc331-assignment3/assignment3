

; Make a list of n length
(define (makelist n)
  (if (= n 1)
    (list 1)
    (cons n (makelist (- n 1)))))


; Randomize the list
(define (random-sort lst)
  (sort lst
    (lambda (x y)
      (equal? 0 (random 2)))))


; Perform ascending sort of list
(define (asc-sort lst)
  (sort lst
    (lambda (x y)
      (< x y))))


; Break into k-sized groups
(define (split-by lst k)
  (if (not (null? lst))
    (cons (asc-sort (take lst k) ) (split-by (drop lst k) k) )
    '() ))


; Number of occurences in a list
(define (occurence x lst)
  (if (null? lst) 
    0
    (if (equal? x (car lst)) 
      (+ 1 (occurence x (cdr lst)))
      (occurence x (cdr lst)))))


; Make candidate grouping
(define (make-group n k)
  (split-by (random-sort (makelist n)) k))


; Appends the assignement list groupings into a single list
(define (append . lsts)
  (cond
    ((null? lsts) '())
    ((null? (car lsts)) (apply append (cdr lsts)))
    (else (cons (caar lsts) (apply append (cdar lsts) (cdr lsts))))))


; Break into k-sized tuples, no sorting of results
(define (split-by-no-sort lst k)
  (if (not (null? lst))
    (cons (take lst k) (split-by-no-sort (drop lst k) k) )
    '() ))


; Determines the total number of times a grouping is repeated
;  within the 8 assignment groupings
(define (total-occurences lst)
  (if (null? lst) 
    0
    (+ 
      (total-occurences (cdr lst)) 
      (occurence (car lst) (cdr lst)))))


; Returns the width in which to display the student number
(define (num-width)
  (if (< n 10)
    1
    (if (< n 100)
      2
      3)))


; Places the student number to display into an appropriately
;  sized field based on the number of students (i.e. 3 spaces
;  if n >= 100, 2 spaces if n >= 10, or 1)
(define (format-value x)
  (string-append
    (make-string 
      (- (num-width) (string-length x)) 
      #\ ) x ))


; Displays the students within a group to the screen in a formatted
;  way to allow all groups to line up
(define (format-cell lst)
  (if (not (null? lst))
    (begin
      (display (format-value (number->string (car (take lst 1)) )))
      (if (> (length lst) 1)
        (display " "))
      (format-cell (drop lst 1)))))


; Displays an individual group to the screen
(define (format-group lst)
  (display "(")
  (format-cell lst)
  (display ")"))

  

; Responsible for displaying an 'assignment' in a formatted
;  manner
(define (display-groups lst)
  (if (not (null? lst))
    (begin
      (format-group (car (take lst 1)) )
      (display " ")
      (display-groups (drop lst 1))))) 


; The messages to precede the data when displayed
(define msgs 
  (vector 
    "\n\nAssignment1: " 
    "Assignment2: " 
    "Assignment3: "
    "Midterm:     "
    "Assignment4: "
    "Assignment5: "
    "Assignment6: "
    "Final Exam:  "))


; Displays the list to the screen
(define (display-the-list lst n idx)
  (if (not (null? lst))
    (begin 
      (display (vector-ref msgs idx))
      (display-groups (take lst n))
      (display "\n")
      (display-the-list (drop lst n) n (+ idx 1)))))


; If list is OK, prints tot he screen and returns a 1
; If list is not OK (has a repeated group), a 0 is returned
(define (display-if-ok lst n k )
  (if (= (total-occurences lst) 0)
    (begin
      (display-the-list lst (/ n k) 0) 
      1 )
    0))


; Creates the k-sized grouping for all 8 assignments
(define (get-data n k)
  (split-by
    (append 
      (random-sort (makelist n)) 
      (random-sort (makelist n)) 
      (random-sort (makelist n)) 
      (random-sort (makelist n)) 
      (random-sort (makelist n)) 
      (random-sort (makelist n)) 
      (random-sort (makelist n)) 
      (random-sort (makelist n)))
    k))


; Verifies the test can be run (number of students is divisible by
;  group size), then starts recursively looking for a solution
(define (run-test n k totalTries)
  (if (not (= (modulo n k) 0))
    (begin
      (display "Can not form full groups of students with n=")
      (display n)
      (display " and k=")
      (display k)
      (display "\n\n"))
    (if (<= totalTries 0)
      (begin
        (display "Could not find a solution for n=")
        (display n)
        (display " and k=")
        (display k)
        (display "\n\n"))
      (if (= 0 (display-if-ok (get-data n k) n k))
        (run-test n k (- totalTries 1))
        (display "Successfully found a solution\n\n")))))
     

(define n 20)
(define k 4)


; Entry point
(run-test n k 1000)
